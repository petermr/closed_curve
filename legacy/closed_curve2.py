"""
hand_drawn_polygons.py

This generative art project visualizes the concept of *error transmission through repetition*.
Starting with a high-resolution circular polygon (e.g., 500 points), each subsequent layer is
generated by tracing the previous one with slight random perturbations. The effect mimics
a human repeatedly redrawing the same shape by hand, where small imperfections accumulate
and drift over time.

The process highlights how even strict geometric systems can take on organic and expressive
qualities when touched by uncertainty. Each inner polygon is slightly "shakier" than the last,
creating a beautiful transition from order to chaos â€” a visual echo of memory, time, and
human imperfection.

Controls:
- Number of layers: how many nested polygons to draw.
- Error scale: how much each point is randomly perturbed (simulates "hand wobble").

Author: ChatGPT + You
"""

import tkinter as tk
from PIL import Image, ImageDraw, ImageTk
import math
import random

# === CONFIGURATION ===
CANVAS_WIDTH = 700
CANVAS_HEIGHT = 700
BACKGROUND_COLOR = (255, 255, 255)
LINE_COLOR = (20, 20, 20)
N_POINTS = 500
BASE_RADIUS = 250

# === CORE FUNCTIONS ===

def generate_base_polygon(n_points, radius):
    """Generate an initial high-res polygon approximating a circle."""
    return [
        (
            radius * math.cos(2 * math.pi * i / n_points),
            radius * math.sin(2 * math.pi * i / n_points)
        )
        for i in range(n_points)
    ]

def perturb_polygon(points, inward=1.0, error_scale=0.5):
    """
    Return a new polygon that perturbs each point inward with added noise.
    Simulates 'hand-drawn' variation in repeated tracing.
    """
    new_points = []
    for x, y in points:
        # Move slightly inward toward origin
        dx, dy = -x, -y
        length = math.hypot(dx, dy) or 1
        nx, ny = dx / length, dy / length
        # Add error
        jitter_x = random.uniform(-1, 1) * error_scale
        jitter_y = random.uniform(-1, 1) * error_scale
        new_x = x + nx * inward + jitter_x
        new_y = y + ny * inward + jitter_y
        new_points.append((new_x, new_y))
    return new_points

def draw_polygons(n_layers, error_scale, canvas_size=(700, 700)):
    """
    Draws a sequence of polygons, each perturbed from the last.
    """
    cx, cy = canvas_size[0] // 2, canvas_size[1] // 2
    image = Image.new("RGB", canvas_size, BACKGROUND_COLOR)
    draw = ImageDraw.Draw(image)

    # Start with circular polygon
    polygon = generate_base_polygon(N_POINTS, BASE_RADIUS)

    for i in range(n_layers):
        # Translate to canvas center
        display_points = [(x + cx, y + cy) for (x, y) in polygon]
        draw.line(display_points + [display_points[0]], fill=LINE_COLOR, width=1)
        polygon = perturb_polygon(polygon, inward=1.5, error_scale=error_scale)

    return image

# === GUI ===

class HandDrawnApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Error Transmission in Hand-Drawn Polygons")

        self.canvas = tk.Canvas(root, width=CANVAS_WIDTH, height=CANVAS_HEIGHT)
        self.canvas.grid(row=0, column=0, columnspan=2)

        self.layers_slider = self.create_slider("Number of Layers", 1, 50, 10, 0)
        self.error_slider = self.create_slider("Error Scale", 0, 5, 1, 1, resolution=0.1)

        self.image_on_canvas = None
        self.update_image()

    def create_slider(self, label, minval, maxval, default, col, resolution=1):
        slider = tk.Scale(
            self.root, from_=minval, to=maxval, orient=tk.HORIZONTAL,
            label=label, resolution=resolution, command=self.update_image
        )
        slider.set(default)
        slider.grid(row=1, column=col, sticky="ew", padx=10)
        return slider

    def update_image(self, event=None):
        n_layers = self.layers_slider.get()
        error_scale = self.error_slider.get()
        img = draw_polygons(n_layers, error_scale, (CANVAS_WIDTH, CANVAS_HEIGHT))
        self.tk_img = ImageTk.PhotoImage(img)

        if self.image_on_canvas is None:
            self.image_on_canvas = self.canvas.create_image(0, 0, anchor="nw", image=self.tk_img)
        else:
            self.canvas.itemconfig(self.image_on_canvas, image=self.tk_img)

# === RUN ===

if __name__ == "__main__":
    root = tk.Tk()
    app = HandDrawnApp(root)
    root.mainloop()
